// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "../TigerDrive/TigerDriveBase.h"
#include "driveCommand.h"

driveCommand::driveCommand() {
	//printf("\n In driveCommand::driveCommand()");

	// Use requires() here to declare subsystem dependencies
	// eg. requires(chassis);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

	Requires(Robot::driveBaseSub);

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	RotateAxis = 0;
	YAxis = 0;
	XAxis = 0;
	ButtonAPressed = false; //180
	ButtonBPressed = false; //135
	ButtonXPressed = false; //-135
	ButtonYPressed = false; //0
	slow_button = false;
	IMU_Raw = 0;
	IMU_Yaw = 0;
	AutoRotCmd = 0;
}

// Called just before this Command runs the first time
void driveCommand::Initialize() {
	//printf("\n In driveCommand::Initialize");

	ButtonAPressed = false; //180
	ButtonBPressed = false; //135
	ButtonXPressed = false; //-135
	ButtonYPressed = false; //0
	//Default values for drive command - joystick overrides these
	XAxis = 0;
	YAxis = 0;
	RotateAxis = 0;
	slow_button = false;

	//printf("\n Done driveCommand::Initialize()");
}

// Called repeatedly when this Command is scheduled to run
void driveCommand::Execute() {
	IMU_Yaw = Robot::driveBaseSub->pTigerDriveBase->GetAdjYaw(IMU_Raw);
	//printf("\n In driveCommand::Execute(");

	//Button press indicates start AutoROtate command
	//Set Rotate Angle Based on Which Button
	ButtonYPressed = Robot::oi->getJoystick1()->GetRawButton(4);
	if(ButtonYPressed == true)
	{
		Robot::driveBaseSub->pTigerDriveBase->SetAngleFunction(0);
	}

	ButtonAPressed = Robot::oi->getJoystick1()->GetRawButton(1);
	if(ButtonAPressed == true)
	{
		Robot::driveBaseSub->pTigerDriveBase->SetAngleFunction(180);
	}

	ButtonBPressed = Robot::oi->getJoystick1()->GetRawButton(2);
	if(ButtonBPressed == true)
	{
		Robot::driveBaseSub->pTigerDriveBase->SetAngleFunction(135);
	}

	ButtonXPressed = Robot::oi->getJoystick1()->GetRawButton(3);
	if(ButtonXPressed == true)
	{
		Robot::driveBaseSub->pTigerDriveBase->SetAngleFunction(-135);
	}



	//Start if the button is pressed and we arent already going, or if we aren't done from previous conditions
	if(((ButtonYPressed ||ButtonXPressed == true || ButtonAPressed == true || ButtonBPressed == true) && AutoRotDone == true) || (AutoRotDone == false))
	{
		//Rotate to Set Angle at Max Speed (1)
		AutoRotCmd = Robot::driveBaseSub->pTigerDriveBase->GetRotateCommand(1, IMU_Yaw);
	}


	//Read current robot orientation angle measured from starting position=0 degrees

	SmartDashboard::PutNumber("Angle of Robot", IMU_Yaw);

	//Get Joystick Values from Driver
	XAxis = Robot::oi->getJoystick1()->GetRawAxis(0);
	YAxis = Robot::oi->getJoystick1()->GetRawAxis(1);
	RotateAxis = Robot::oi->getJoystick1()->GetRawAxis(4);
	slow_button = Robot::oi->getJoystick1()->GetRawButton(6);

	if(slow_button == true)
	{
		XAxis = XAxis / 1.5;
		YAxis = YAxis / 2;
		RotateAxis = RotateAxis / 2;
	}

	//Sets up deadbands (this gets rid of the robot moving very slowly
	//even when you are not touching the joystick. Because the joystick
	//is never really at zero, (for example 0.0389583), this checks if
	//any joystick is in the range of -0.20 to 0.20 and if it is sets it
	//to zero, if not, sends the current value to the MechDrive function.

	//Also squares the values which increases sensitivity, and (mostly) blends out
	//the discontinuity you would have with just the dead band (there's no step from 0 to .2,
	//the lowest value is 0 to .04 now.

	if(XAxis > -0.20 && XAxis < 0.20)
	{
		XAxis = 0;
	}
	else
	{
		XAxis = XAxis * fabs(XAxis);
	}



	if(YAxis > -0.20 && YAxis < 0.20)
	{
		YAxis = 0;
	}
	else
	{
		YAxis = YAxis * fabs(YAxis);
	}


	
	if(RotateAxis > -0.20 && RotateAxis < 0.20)
	{
		RotateAxis = 0;
	}
	else
	{
		RotateAxis = RotateAxis * fabs(RotateAxis);
	}

	//SmartDashboard::PutNumber("JoyX", XAxis);
	//SmartDashboard::PutNumber("JoyY", YAxis);
	//SmartDashboard::PutNumber("JoyRot", RotateAxis);


	//Allow the driver to override a previous auto-rotation command
	//Auto Rotation
	if(RotateAxis == 0)
	{
		Robot::driveBaseSub->MechDrive(XAxis,YAxis,AutoRotCmd,IMU_Yaw);

		//printf("\n Command Drive with AutoRotate");
	}
	//Driver rotation
	else
	{
		Robot::driveBaseSub->MechDrive(XAxis,YAxis,RotateAxis,IMU_Yaw);
		TimesThroughLoop = 0;  //reset the loop/overshoot counter any time driver overrides
		AutoRotDone = true;

		//printf("\n Command Drive with Driver / Joystick Rotation (If Any)");
	}


	//printf("\n Leaving driveCommand::Execute()");


}

// Make this return true when this Command no longer needs to run execute()
bool driveCommand::IsFinished() {
	//printf("\n In driveCommand::IsFinished()");
	return false;
}

// Called once after isFinished returns true
void driveCommand::End() {
	//printf("\n In driveCommand::End()");
	//Robot::driveBaseSub->MechDrive(0,0,0,0);
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void driveCommand::Interrupted() {
	//printf("\n In driveCommand::Interrupted()");
	//Robot::driveBaseSub->MechDrive(0,0,0,0);
}
